<!DOCTYPE html>
<html>

  <head>
    <meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta http-equiv="X-UA-Compatible" content="IE=edge">

<title>Wen  Xiao | Chu-Liu/Edmonds' Algorithm for Max Spanning Tree in Di-graph</title>
<meta name="description" content="Hey! This is a PhD student at University of British Columbia, with focus on NLP. 
">

<!-- Open Graph -->


<!-- Bootstrap & MDB -->
<link href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css" rel="stylesheet" integrity="sha512-MoRNloxbStBcD8z3M/2BmnT+rg4IsMxPkXaGh2zD6LGNNFE80W3onsAhRcMAMrSoyWL9xD7Ert0men7vR8LUZg==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/css/mdb.min.css" integrity="sha512-RO38pBRxYH3SoOprtPTD86JFOclM51/XTIdEPh5j8sj4tp8jmQIx26twG52UaLi//hQldfrh7e51WzP9wuP32Q==" crossorigin="anonymous" />

<!-- Fonts & Icons -->
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.14.0/css/all.min.css"  integrity="sha512-1PKOgIY59xJ8Co8+NE6FZ+LOAZKjy+KY8iq0G4B3CyeY6wYHN3yt9PW0XpSriVlkMXe40PTKnXrLnZ9+fkDaog==" crossorigin="anonymous">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/academicons/1.9.0/css/academicons.min.css" integrity="sha512-W4yqoT1+8NLkinBLBZko+dFB2ZbHsYLDdr50VElllRcNt2Q4/GSs6u71UHKxB7S6JEMCp5Ve4xjh3eGQl/HRvg==" crossorigin="anonymous">
<link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons">

<!-- Code Syntax Highlighting -->
<link rel="stylesheet" href="https://gitcdn.xyz/repo/jwarby/jekyll-pygments-themes/master/github.css" />

<!-- Styles -->

<link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>ðŸ”¥</text></svg>">

<link rel="stylesheet" href="/assets/css/main.css">
<link rel="canonical" href="/blog/2020/chuliuemdond_algorithm/">

<!-- JQuery -->
<!-- jQuery -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js" integrity="sha512-bLT0Qm9VnAYZDflyKcBaQ2gg0hSYNQrJ8RilYldYQ1FxQYoCLtUjuuRuZo+fjqhx/qtq/1itJ0C2ejDxltZVFg==" crossorigin="anonymous"></script>


<!-- Theming-->

<script src="/assets/js/theme.js"></script>
<script src="/assets/js/dark_mode.js"></script>






    
<!-- MathJax -->
<script type="text/javascript">
  window.MathJax = {
    tex: {
      tags: 'ams'
    }
  };
</script>
<script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.1.2/es5/tex-mml-chtml.js"></script>
<script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>


  </head>

  <body class="fixed-top-nav ">

    <!-- Header -->

    <header>

    <!-- Nav Bar -->
    <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top">
    <div class="container">
      
      <a class="navbar-brand title font-weight-lighter" href="/">
       <span class="font-weight-bold">Wen</span>   Xiao
      </a>
      
      <!-- Navbar Toggle -->
      <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation">
        <span class="sr-only">Toggle navigation</span>
        <span class="icon-bar top-bar"></span>
        <span class="icon-bar middle-bar"></span>
        <span class="icon-bar bottom-bar"></span>
      </button>
      <div class="collapse navbar-collapse text-right" id="navbarNav">
        <ul class="navbar-nav ml-auto flex-nowrap">
          <!-- About -->
          <li class="nav-item ">
            <a class="nav-link" href="/">
              about
              
            </a>
          </li>
          
          <!-- Blog -->
          <li class="nav-item active">
            <a class="nav-link" href="/blog/">
              blog
              
            </a>
          </li>
          
          <!-- Other pages -->
          
          
          
          
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/projects/">
                Projects
                
              </a>
          </li>
          
          
          
          <li class="nav-item ">
              <a class="nav-link" href="/publications/">
                Publications
                
              </a>
          </li>
          
          
          
          
          
            <div class = "toggle-container">
              <a id = "light-toggle">
                  <i class="fas fa-moon"></i>
                  <i class="fas fa-sun"></i>
              </a>
            </div>
          
        </ul>
      </div>
    </div>
  </nav>

</header>


    <!-- Content -->

    <div class="container mt-5">
      

<div class="post">

  <header class="post-header">
    <h1 class="post-title">Chu-Liu/Edmonds' Algorithm for Max Spanning Tree in Di-graph</h1>
    <p class="post-meta">July 10, 2020</p>
  </header>

  <article class="post-content">
    <p>In this blog, I will introduce the algorithm to find the maximum spanning tree in the directed graphs - the Chu-Liu/Edmondsâ€™ Algorithm.</p>

<h3 id="problem-definition"><span style="color:blue">Problem Definition</span></h3>
<p>Given a connected directed graph \(G=\{V,E\}\) with vertices \(V=\{v_1,v_2,...,v_n\}\) and edges \(E=\{e_{12},...,e_{ij}\}\), in which \(e_{ij}\) represents the edge from vertex \(v_i\) to \(v_j\) with weight \(w(e_{ij})\) the goal is to find the maximum spanning tree \(T=\{V,E^t\}\) where all the vertices are connected, each node (except the root) has only one incoming edge, and the sum of weights of the edges is the maximum.</p>

<h3 id="a-step-by-step-explanation-of-chu-liuedmonds-algorithm"><span style="color:blue">A Step-by-Step Explanation of Chu-Liu/Edmondsâ€™ Algorithm</span></h3>
<p>The Chu-Liu/Edmondsâ€™ algorithm is designed in a recursive manner, to better explain the idea, Iâ€™ll show the algorithm step-by-step with an example.</p>
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <p align="center"><img class="img-fluid rounded z-depth-1" src="/assets/img/chuliuedmonds/chuliu_g1.png" /></p>
    </div>
</div>
<div class="caption">
    An example of a fully connected directed graph with four vertices.
</div>

<h4 id="step-zero">Step Zero</h4>
<p>Given the graph shown above, the first step is to decide the start point, i.e. the root of the tree. It can be predefined by the user, otherwise, the root is the node with the highest sum of outgoing edges, \(r=\arg\max_{v_i\in V}\sum_{v_j \in V} e_{ji}\). Then as the root can only have the outgoing edges, we remove all the incoming edges of the root.</p>

<p>In this case, the root is node 1 and after removing the unnecessary edges, the resulting graph is shown as:</p>
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <p align="center"><img class="img-fluid rounded z-depth-1" src="/assets/img/chuliuedmonds/chuliu_g2.png" /></p>
    </div>
</div>

<h4 id="step-one">Step One</h4>
<p>First, we start from the graph \(MG\) with the maximum incoming edge for each node (other than the root), i.e. for each node \(v_i\), there is only one incoming edge from node \(\pi(v_i)\), denoting \(e_{\pi(v_i)v_i}\), and it is the edge with the maximum weight. If the graph is a tree, then it is the maximum spanning tree, otherwise, the graph contains at least one circle, then we need to break the circles by replacing certain edges with edges outside the graph \(MG\).</p>

<p>Back to the example, the green edges in the following graph forms the graph \(MG\), and we can find a circle between node \(2\) and node \(3\).</p>
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <p align="center"><img class="img-fluid rounded z-depth-1" src="/assets/img/chuliuedmonds/chuliu_g3.png" /></p>
    </div>
</div>

<h4 id="step-two-recursive-call">Step Two (recursive call)</h4>
<p>Randomly picking one circle \(C_{node}=\{v_{c_1},v_{c_2},...v_{c_k}\}\) in \(MG\), the circle itself is optimal, and we only need to break the circle with the minimum cost. To achieve this, we first build a new graph \(G'\) by treating the circle as a new node \(v_C\), and then find the maximum spanning tree \(A\) in the new graph \(G'\) (recursively run the algorithm on \(G'\)).</p>

<p>Now we first decribe the way to build new graph \(G'=\{V',E'\}\) with the vertex set \(V'=V \setminus C\cup\{v_C\}\). As for the edges \(E'\), we split them into three cases:</p>

<ol>
  <li>For edge \(e_{sd}\) in \(E\), if \(s\notin C_{node}\) and \(d\in C_{node}\), then we add an edge \(e_{sv_C}'\) to \(E'\) with weight \(w(e_{sv_C}')=w(e_{sd})-w(e_{\pi(v_d)v_d})\) (it is a negative value)</li>
  <li>For edge \(e_{sd}\) in \(E\), if \(s\in C_{node}\) and \(d\notin C_{node}\), then we add an edge \(e_{v_Cd}'\) to \(E'\) with weight \(w(e_{v_C d}')=w(e_{sd})\)</li>
  <li>For edge \(e_{sd}\) in \(E\), if \(s\notin C_{node}\) and \(d\notin C_{node}\), then we add an edge \(e_{sd}'\) to \(E'\) with weight \(w(e_{sd}')=w(e_{sd})\)</li>
</ol>

<p>Then there might be multiple edges between \(v_C\) and other nodes, we only keep the edge with maximum weight between \(v_C\) and each other node.</p>

<p>In this example, there is only one circle formed by node \(2\) and node \(3\), so we treat the circle as a new node \(v_C\), as shown in the left figure below. Then by applying the rules mentioned above, we build the new graph \(G'\) shown in the left. Apparently there are multiple edges between node \(1,4\) and node \(v_C\), then we only keep the one with the highest weight (i.e. the blue edges, and the number in the parenthesis represents the original source/destinition of the edge in the circle).</p>
<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <p align="center"><img class="img-fluid rounded z-depth-1" src="/assets/img/chuliuedmonds/chuliu_g4.png" /></p>
    </div>
</div>

<p>Then we need to find the maximum spanning tree \(A\) for the new graph \(G'\), and it is formed by the edges in red in the figure below.</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <p align="center"><img class="img-fluid rounded z-depth-1" src="/assets/img/chuliuedmonds/chuliu_g5.png" /></p>
    </div>
</div>

<h4 id="step-three">Step Three</h4>
<p>Without loss of generality, assume the incoming edge of \(v_C\) in \(A\) is from node \(v_s\) and its corresponding edge in the original graph \(G\) is \(e_{sk}\), with \(v_k \in C_{node}\), then the edges of the final tree is  formed by the combination of edges in \(A\) (replacing the edges from/to \(v_C\) to the original edge) and the edges in the circle without the incoming edge of node \(v_k\).</p>

<p>As shown in the graph below, \(E^t\) is formed by the red edges in the right figure.</p>

<div class="row mt-3">
    <div class="col-sm mt-3 mt-md-0">
        <p align="center"><img class="img-fluid rounded z-depth-1" src="/assets/img/chuliuedmonds/chuliu_g6.png" /></p>
    </div>
</div>

<div class="caption">
    We got it! Congrats! ^.^
</div>

<h3 id="python-implementation"><span style="color:blue">Python Implementation</span></h3>
<p>In this section, Iâ€™ll show my python implementation of the algorithm. There must be more efficient implementations, and discussions on improving the implementation are welcome.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><table class="rouge-table"><tbody><tr><td class="gutter gl"><pre class="lineno">1
2
3
4
5
6
7
8
9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98
99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
</pre></td><td class="code"><pre><span class="k">def</span> <span class="nf">reverse_graph</span><span class="p">(</span><span class="n">G</span><span class="p">):</span>
    <span class="s">'''Return the reversed graph where g[dst][src]=G[src][dst]'''</span>
    <span class="n">g</span><span class="o">=</span><span class="p">{}</span>
    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">G</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">for</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">dst</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">g</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">g</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
            <span class="n">g</span><span class="p">[</span><span class="n">dst</span><span class="p">][</span><span class="n">src</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">dst</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">g</span>

<span class="k">def</span> <span class="nf">build_max</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span><span class="n">root</span><span class="p">):</span>
    <span class="s">'''Find the max in-edge for every node except for the root.'''</span>
    <span class="n">mg</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="k">for</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">rg</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="k">if</span> <span class="n">dst</span><span class="o">==</span><span class="n">root</span><span class="p">:</span>
            <span class="k">continue</span>
        <span class="n">max_ind</span><span class="o">=-</span><span class="mi">100</span>
        <span class="n">max_value</span> <span class="o">=</span> <span class="o">-</span><span class="mi">100</span>
        <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">rg</span><span class="p">[</span><span class="n">dst</span><span class="p">].</span><span class="n">keys</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">rg</span><span class="p">[</span><span class="n">dst</span><span class="p">][</span><span class="n">src</span><span class="p">]</span><span class="o">&gt;=</span><span class="n">max_value</span><span class="p">:</span>
                <span class="n">max_ind</span> <span class="o">=</span> <span class="n">src</span>
                <span class="n">max_value</span> <span class="o">=</span> <span class="n">rg</span><span class="p">[</span><span class="n">dst</span><span class="p">][</span><span class="n">src</span><span class="p">]</span>
        <span class="n">mg</span><span class="p">[</span><span class="n">dst</span><span class="p">]</span><span class="o">=</span><span class="p">{</span><span class="n">max_ind</span><span class="p">:</span><span class="n">max_value</span><span class="p">}</span>
    <span class="k">return</span> <span class="n">mg</span>

<span class="k">def</span> <span class="nf">find_circle</span><span class="p">(</span><span class="n">mg</span><span class="p">):</span>
    <span class="s">'''Return the firse circle if find, otherwise return None'''</span>
        
    <span class="k">for</span> <span class="n">start</span> <span class="ow">in</span> <span class="n">mg</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
        <span class="n">visited</span><span class="o">=</span><span class="p">[]</span>
        <span class="n">stack</span> <span class="o">=</span> <span class="p">[</span><span class="n">start</span><span class="p">]</span>
        <span class="k">while</span> <span class="n">stack</span><span class="p">:</span>
            <span class="n">n</span> <span class="o">=</span> <span class="n">stack</span><span class="p">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                <span class="n">C</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">while</span> <span class="n">n</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
                    <span class="n">C</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
                    <span class="n">n</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mg</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">return</span> <span class="n">C</span>
            <span class="n">visited</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n</span> <span class="ow">in</span> <span class="n">mg</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">stack</span><span class="p">.</span><span class="n">extend</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">mg</span><span class="p">[</span><span class="n">n</span><span class="p">].</span><span class="n">keys</span><span class="p">()))</span>
    <span class="k">return</span> <span class="bp">None</span>
        
<span class="k">def</span> <span class="nf">chu_liu_edmond</span><span class="p">(</span><span class="n">G</span><span class="p">,</span><span class="n">root</span><span class="p">):</span>
    <span class="s">''' G: dict of dict of weights
            G[i][j] = w means the edge from node i to node j has weight w.
            Assume the graph is connected and there is at least one spanning tree existing in G.
        root: the root node, has outgoing edges only.
    '''</span>
    <span class="c1"># reversed graph rg[dst][src] = G[src][dst]
</span>    <span class="n">rg</span> <span class="o">=</span> <span class="n">reverse_graph</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="c1"># root only has out edge
</span>    <span class="n">rg</span><span class="p">[</span><span class="n">root</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
    <span class="c1"># the maximum edge for each node other than root
</span>    <span class="n">mg</span> <span class="o">=</span> <span class="n">build_max</span><span class="p">(</span><span class="n">rg</span><span class="p">,</span><span class="n">root</span><span class="p">)</span>
    
    <span class="c1"># check if mg is a tree (contains a circle)
</span>    <span class="n">C</span> <span class="o">=</span> <span class="n">find_circle</span><span class="p">(</span><span class="n">mg</span><span class="p">)</span>
    <span class="c1"># if there is no circle, it means mg is what we want
</span>    <span class="k">if</span> <span class="ow">not</span> <span class="n">C</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">reverse_graph</span><span class="p">(</span><span class="n">mg</span><span class="p">)</span>
    <span class="c1"># Now consider the nodes in the circle C as one new node vc
</span>    <span class="n">all_nodes</span> <span class="o">=</span> <span class="n">G</span><span class="p">.</span><span class="n">keys</span><span class="p">()</span>
    <span class="n">vc</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span><span class="o">+</span><span class="mi">1</span>
    
    <span class="c1">#The new graph G_prime with V_prime=V\C+{vc} 
</span>    <span class="n">V_prime</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">all_nodes</span><span class="p">)</span><span class="o">-</span><span class="nb">set</span><span class="p">(</span><span class="n">C</span><span class="p">))</span><span class="o">+</span><span class="p">[</span><span class="n">vc</span><span class="p">]</span>
    <span class="n">G_prime</span> <span class="o">=</span> <span class="p">{}</span>
    <span class="n">vc_in_idx</span><span class="o">=</span><span class="p">{}</span>
    <span class="n">vc_out_idx</span><span class="o">=</span><span class="p">{}</span>
    <span class="c1"># Now add the edges to G_prime
</span>    <span class="k">for</span> <span class="n">u</span> <span class="ow">in</span> <span class="n">all_nodes</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">].</span><span class="n">keys</span><span class="p">():</span>
            <span class="c1"># First case: if the source is not in the circle, and the dest is in the circle, i.e. in-edges for C
</span>            <span class="c1"># Then we only keep one edge from each node that is not in C to the new node vc with the largest difference (G[u][v]-list(mg[v].values())[0])
</span>            <span class="c1"># To specify, for each node u in V\C, there is an edge between u and vc if and only if there is an edge between u and any node v in C,
</span>            <span class="c1"># And the weight of edge u-&gt;vc = max_{v in C} (G[u][v] - mg[v].values) The second term represents the weight of max in-edge of v.
</span>            <span class="c1"># Then we record that the edge u-&gt;vc is originally the edge u-&gt;v with v=argmax_{v in C} (G[u][v] - mg[v].values)
</span>            
            <span class="k">if</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span> <span class="n">C</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G_prime</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">G_prime</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span><span class="o">-</span><span class="nb">list</span><span class="p">(</span><span class="n">mg</span><span class="p">[</span><span class="n">v</span><span class="p">].</span><span class="n">values</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">vc</span> <span class="ow">not</span> <span class="ow">in</span>  <span class="n">G_prime</span><span class="p">[</span><span class="n">u</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">vc</span> <span class="ow">in</span>  <span class="n">G_prime</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">G_prime</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">vc</span><span class="p">]):</span>
                    <span class="n">G_prime</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">vc</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
                    <span class="n">vc_in_idx</span><span class="p">[</span><span class="n">u</span><span class="p">]</span> <span class="o">=</span> <span class="n">v</span>
            <span class="c1"># Second case: if the source is in the circle, but the dest is not in the circle, i.e out-edge for C
</span>            <span class="c1"># Then we only keep one edge from the new node vc to each node that is not in C
</span>            <span class="c1"># To specify, for each node v in V\C, there is an edge between vc and v iff there is an edge between any edge u in C and v.
</span>            <span class="c1"># And the weight of edge vc-&gt;v = max_{u in C} G[u][v] 
</span>            <span class="c1"># Then we record that the edge vc-&gt;v originally the edge u-&gt;v with u=argmax_{u in C} G[u][v] 
</span>            <span class="k">elif</span> <span class="p">(</span><span class="n">u</span> <span class="ow">in</span> <span class="n">C</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">vc</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G_prime</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">G_prime</span><span class="p">[</span><span class="n">vc</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                <span class="n">w</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span>  <span class="n">G_prime</span><span class="p">[</span><span class="n">vc</span><span class="p">])</span> <span class="ow">or</span> <span class="p">(</span><span class="n">v</span> <span class="ow">in</span>  <span class="n">G_prime</span><span class="p">[</span><span class="n">vc</span><span class="p">]</span> <span class="ow">and</span> <span class="n">w</span> <span class="o">&gt;</span> <span class="n">G_prime</span><span class="p">[</span><span class="n">vc</span><span class="p">][</span><span class="n">v</span><span class="p">]):</span>
                    <span class="n">G_prime</span><span class="p">[</span><span class="n">vc</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">w</span>
                    <span class="n">vc_out_idx</span><span class="p">[</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">u</span>
            <span class="c1"># Third case: if the source and dest are all not in the circle, then just add the edge to the new graph.
</span>            <span class="k">elif</span> <span class="p">(</span><span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">)</span> <span class="ow">and</span> <span class="p">(</span><span class="n">v</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">C</span><span class="p">):</span>
                <span class="k">if</span> <span class="n">u</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">G_prime</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">G_prime</span><span class="p">[</span><span class="n">u</span><span class="p">]</span><span class="o">=</span><span class="p">{}</span>
                <span class="n">G_prime</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">u</span><span class="p">][</span><span class="n">v</span><span class="p">]</span>
    <span class="c1"># Recursively run the algorihtm on the new graph G_prime
</span>    <span class="c1"># The result A should be a tree with nodes V\C+vc, then we just need to break the circle C and plug the subtree into A
</span>    <span class="c1"># To break the circle, we need to use the in-edge of vc, say u-&gt;vc to replace the original selected edge u-&gt;v, 
</span>    <span class="c1"># where v was the original edge we recorded in the first case above.
</span>    <span class="c1"># Then if vc has out-edges, we also need to replace them with the original edges, recorded in the second case above.
</span>    <span class="n">A</span> <span class="o">=</span> <span class="n">chu_liu_edmond</span><span class="p">(</span><span class="n">G_prime</span><span class="p">,</span><span class="n">root</span><span class="p">)</span>
    <span class="k">print</span><span class="p">(</span><span class="n">A</span><span class="p">)</span>
    <span class="n">all_nodes_A</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">A</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
    <span class="k">for</span> <span class="n">src</span> <span class="ow">in</span> <span class="n">all_nodes_A</span><span class="p">:</span>
        <span class="c1"># The number of out-edges varies, could be 0 or any number &lt;=|V\C|
</span>        <span class="k">if</span> <span class="n">src</span><span class="o">==</span><span class="n">vc</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">node_in</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">src</span><span class="p">].</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">orig_out</span> <span class="o">=</span> <span class="n">vc_out_idx</span><span class="p">[</span><span class="n">node_in</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">orig_out</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">A</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">orig_out</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
                <span class="n">A</span><span class="p">[</span><span class="n">orig_out</span><span class="p">][</span><span class="n">node_in</span><span class="p">]</span><span class="o">=</span><span class="n">G</span><span class="p">[</span><span class="n">orig_out</span><span class="p">][</span><span class="n">node_in</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">dst</span> <span class="ow">in</span> <span class="n">A</span><span class="p">[</span><span class="n">src</span><span class="p">]:</span>
                <span class="c1"># There must be only one in-edge to vc.
</span>                <span class="k">if</span> <span class="n">dst</span><span class="o">==</span><span class="n">vc</span><span class="p">:</span>
                    <span class="n">orig_in</span> <span class="o">=</span> <span class="n">vc_in_idx</span><span class="p">[</span><span class="n">src</span><span class="p">]</span>
                    <span class="n">A</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">orig_in</span><span class="p">]</span> <span class="o">=</span> <span class="n">G</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">orig_in</span><span class="p">]</span>
                    <span class="k">del</span> <span class="n">A</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">dst</span><span class="p">]</span>
    <span class="k">del</span> <span class="n">A</span><span class="p">[</span><span class="n">vc</span><span class="p">]</span>
    
    <span class="c1"># Now add the edges from the circle to the result.
</span>    <span class="c1"># Remember not to include the one with new in-edge
</span>    <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="n">C</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="n">orig_in</span><span class="p">:</span>
            <span class="n">src</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="n">mg</span><span class="p">[</span><span class="n">node</span><span class="p">].</span><span class="n">keys</span><span class="p">())[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">src</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">A</span><span class="p">.</span><span class="n">keys</span><span class="p">():</span>
                <span class="n">A</span><span class="p">[</span><span class="n">src</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="n">A</span><span class="p">[</span><span class="n">src</span><span class="p">][</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="n">mg</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">src</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">A</span> 
</pre></td></tr></tbody></table></code></pre></figure>

<h3 id="summary"><span style="color:blue">Summary</span></h3>

<p>In this blog, I introduced the traditional algorithm for finding the maximum/minimum spanning tree in the directed graph, and showed a python implementation of the algorithm. The algorithm is often used in the NLP area, especially in the topic like syntactic parsing/discourse parsing. Discussions on the implementation, the algorithm, or the applications are welcome.</p>

<h3 id="reference">Reference</h3>
<p>[1] <a href="https://en.wikipedia.org/wiki/Edmonds%27_algorithm">https://en.wikipedia.org/wiki/Edmonds%27_algorithm</a>  Wikipedia of Edmondsâ€™ algorithm</p>

  </article>

  
    <div id="disqus_thread"></div>
    <script type="text/javascript">
      var disqus_shortname  = 'Wen';
      var disqus_identifier = '/blog/2020/chuliuemdond_algorithm';
      var disqus_title      = "Chu-Liu/Edmonds' Algorithm for Max Spanning Tree in Di-graph";
      (function() {
        var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
      })();
    </script>
    <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
  

</div>

    </div>

    <!-- Footer -->

    
<footer class="fixed-bottom">
  <div class="container mt-0">
    &copy; Copyright 2021 Wen  Xiao.
    Powered by <a href="http://jekyllrb.com/" target="_blank">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank">GitHub Pages</a>.

    
    
  </div>
</footer>



  </body>

  <!-- Bootsrap & MDB scripts -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/popper.js/2.4.4/umd/popper.min.js" integrity="sha512-eUQ9hGdLjBjY3F41CScH3UX+4JDSI9zXeroz7hJ+RteoCaY+GP/LDoM8AO+Pt+DRFw3nXqsjh9Zsts8hnYv8/A==" crossorigin="anonymous"></script>
<script src="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/js/bootstrap.min.js" integrity="sha512-M5KW3ztuIICmVIhjSqXe01oV2bpe248gOxqmlcYrEzAvws7Pw3z6BK0iGbrwvdrUQUhi3eXgtxp5I8PDo9YfjQ==" crossorigin="anonymous"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/mdbootstrap/4.19.1/js/mdb.min.js" integrity="sha512-Mug9KHKmroQFMLm93zGrjhibM2z2Obg9l6qFG2qKjXEXkMp/VDkI4uju9m4QKPjWSwQ6O2qzZEnJDEeCw0Blcw==" crossorigin="anonymous"></script>

  
<!-- Mansory & imagesLoaded -->
<script defer src="https://unpkg.com/masonry-layout@4/dist/masonry.pkgd.min.js"></script>
<script defer src="https://unpkg.com/imagesloaded@4/imagesloaded.pkgd.min.js"></script>
<script defer src="/assets/js/mansory.js" type="text/javascript"></script>


  


<!-- Medium Zoom JS -->
<script src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.6/dist/medium-zoom.min.js" integrity="sha256-EdPgYcPk/IIrw7FYeuJQexva49pVRZNmt3LculEr7zM=" crossorigin="anonymous"></script>
<script src="/assets/js/zoom.js"></script>


<!-- Load Common JS -->
<script src="/assets/js/common.js"></script>


</html>
